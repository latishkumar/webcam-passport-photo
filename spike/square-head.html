<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"
		crossorigin="anonymous"></script>
</head>
<style>
	html,
	body {
		padding: 0;
		margin: 0;
	}

	.canvas_container {
		margin: 0 auto;
		overflow: hidden;
		display: flex;
		align-items: center;
		justify-content: center;
		background-repeat: no-repeat;
		background-position: center;
		background-size: 100%;
	}
</style>

<body>
	<div class="canvas_container">
		<canvas class="output_canvas"></canvas>
	</div>
	<button class="flip">Flip</button><span class="meta_info"></span>
	<script>
		const canvasContainer = document.getElementsByClassName('canvas_container')[0];
		const canvasElement = document.getElementsByClassName('output_canvas')[0];
		const flip = document.getElementsByClassName('flip')[0];
		const meta_info = document.getElementsByClassName('meta_info')[0];
		const canvasCtx = canvasElement.getContext('2d');
		const facingMode = ['user', 'environment'];
		let camera, video;
		let facingModeIndex = 0;

		let videoWidth, videoHeight, videoRatio;
		let smallestWindowDimension = Math.min(window.innerWidth, window.innerHeight);

		flip.addEventListener('click', () => {
			stopCamera();
			facingModeIndex = (facingModeIndex + 1) % facingMode.length;
			startCamera();
		});

		window.onresize = () => {
			smallestWindowDimension = Math.min(window.innerWidth, window.innerHeight);
			resizeOutput();
		}

		function resizeOutput() {
			canvasElement.style.height = `${smallestWindowDimension}px`;
			canvasElement.style.width = `${smallestWindowDimension * videoRatio}px`;

			canvasContainer.style.width = `${smallestWindowDimension}px`;
			canvasContainer.style.height = `${smallestWindowDimension}px`;
			canvasContainer.style.backgroundImage = 'url(./passport-mask.png)';

			canvasElement.height = smallestWindowDimension;
			canvasElement.width = smallestWindowDimension * videoRatio;
		}

		function onResults(results) {
			canvasCtx.save();
			canvasCtx.clearRect(0, 0, smallestWindowDimension * videoRatio, smallestWindowDimension);
			canvasCtx.drawImage(results.segmentationMask, 0, 0,
				smallestWindowDimension * videoRatio, smallestWindowDimension);

			// Only overwrite existing pixels.
			canvasCtx.globalCompositeOperation = 'source-in';
			canvasCtx.drawImage(
				results.image, 0, 0, smallestWindowDimension * videoRatio, smallestWindowDimension);

			canvasCtx.restore();
		}

		const selfieSegmentation = new SelfieSegmentation({
			locateFile: (file) => {
				return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
			}
		});
		selfieSegmentation.setOptions({
			selfieMode: true,
			modelSelection: 0,
		});
		selfieSegmentation.onResults(onResults);

		function startCamera() {
			const mode = facingMode[facingModeIndex];
			video = document.createElement('video');
			video.setAttribute('playsinline', 'true');
			let firstFrame = true;
			camera = new Camera(video, {
				onFrame: async () => {
					if (firstFrame) {
						firstFrame = false;
						videoWidth = video.videoWidth;
						videoHeight = video.videoHeight;
						videoRatio = videoWidth / videoHeight;
						resizeOutput();
						meta_info.textContent = `${mode}, ${video.videoWidth}, ${video.videoHeight}`;
					}
					await selfieSegmentation.send({ image: video });
				},
				facingMode: mode,
				width: 720,
				height: 720
			});
			camera.start();
		}

		function stopCamera() {
			camera && camera.stop();
			video && video.remove();
		}

		startCamera();
	</script>
</body>

</html>